## [LeetCode 127](https://leetcode.com/problems/word-ladder/) Word Ladder (hard)

- A **transformation sequence** from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:
    -   Every adjacent pair of words differs by a single letter.
    -   Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.
    -   `sk == endWord`
- Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return _the **number of words** in the **shortest transformation sequence** from_ `beginWord` _to_ `endWord`_, or_ `0` _if no such sequence exists._
- **Example 1:**
    - **Input:** beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
    - **Output:** 5
    - **Explanation:** One shortest transformation sequence is "hit" -> "hot" -> "dot" -> "dog" -> cog", which is 5 words long.
- **Example 2:**
    - **Input:** beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
    - **Output:** 0
    - **Explanation:** The endWord "cog" is not in wordList, therefore there is no valid transformation sequence.
- **Constraints:**
    -   `1 <= beginWord.length <= 10`
    -   `endWord.length == beginWord.length`
    -   `1 <= wordList.length <= 5000`
    -   `wordList[i].length == beginWord.length`
    -   `beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.
    -   `beginWord != endWord`
    -   All the words in `wordList` are **unique**.

### Solution: bfs

```java
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    int len = beginWord.length();
    Map<String, List<String>> map = new HashMap<>();
    for (String s : wordList) {
        for (int i = 0; i < len; i++) {
            String newWord = s.substring(0, i) + '*' + s.substring(i + 1, len);
            map.computeIfAbsent(newWord, k -> new ArrayList<>()).add(s);
        }
    }
    Queue<Pair<String, Integer>> queue = new ArrayDeque<>();
    queue.offer(new Pair(beginWord, 1));
    Set<String> visited = new HashSet<>();
    visited.add(beginWord);
    while (!queue.isEmpty()) {
        Pair<String, Integer> node = queue.poll();
        String word = node.getKey();
        int level = node.getValue();
        for (int i = 0; i < len; i++) {
            String newWord = word.substring(0, i) + '*' + word.substring(i + 1, len);
            for (String neighbor : map.getOrDefault(newWord, Collections.emptyList())) {
                if (neighbor.equals(endWord)) {
                    return level + 1;
                }
                if (!visited.contains(neighbor)) {
                    queue.offer(new Pair(neighbor, level + 1));
                    visited.add(neighbor);
                }
            }
        }
    }
    return 0;
}
```

Time Complexity: O(wordLen^2 * setLen)

Space Complexity: O(wordLen^2 * setLen)
