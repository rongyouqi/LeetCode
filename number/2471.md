## [LeetCode 2471](https://leetcode.com/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/) Minimum Number of Operations to Sort a Binary Tree by Level (medium)

- You are given the `root` of a binary tree with **unique values**.
- In one operation, you can choose any two nodes **at the same level** and swap their values.
- Return _the minimum number of operations needed to make the values at each level sorted in a **strictly increasing order**_.
- The **level** of a node is the number of edges along the path between it and the root node.
- **Example 1:**
    - <img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174006-2.png" style="zoom:67%;" />
    - **Input:** root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]
    - **Output:** 3
    - **Explanation:**
        - Swap 4 and 3. The 2nd level becomes [3,4].
        - Swap 7 and 5. The 3rd level becomes [5,6,8,7].
        - Swap 8 and 7. The 3rd level becomes [5,6,7,8].
        - We used 3 operations so return 3.
        - It can be proven that 3 is the minimum number of operations needed.
- **Example 2:**
    - <img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174026-3.png" style="zoom:67%;" />
    - **Input:** root = [1,3,2,7,6,5,4]
    - **Output:** 3
    - **Explanation:**
        - Swap 3 and 2. The 2nd level becomes [2,3].
        - Swap 7 and 4. The 3rd level becomes [4,6,5,7].
        - Swap 6 and 5. The 3rd level becomes [4,5,6,7].
        - We used 3 operations so return 3.
        - It can be proven that 3 is the minimum number of operations needed.
- **Example 3:**
    - <img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174052-4.png" style="zoom:67%;" />
    - **Input:** root = [1,2,3,4,5,6]
    - **Output:** 0
    - **Explanation:** Each level is already sorted in increasing order so return 0.
- **Constraints:**
    -   The number of nodes in the tree is in the range `[1, 10^5]`.
    -   `1 <= Node.val <= 10^5`
    -   All the values of the tree are **unique**.

### Solution

```java
public int minimumOperations(TreeNode root) {
    if (root == null) {
        return 0;
    }
    Queue<TreeNode> q = new ArrayDeque<>();
    q.offer(root);
    int result = 0;
    while (!q.isEmpty()) {
        int len = q.size();
        int[] dp = new int[len];
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < len; i++) {
            TreeNode node = q.poll();
            dp[i] = node.val;
            map.put(node.val, i);
            if (node.left != null) {
                q.offer(node.left);
            }
            if (node.right != null) {
                q.offer(node.right);
            }
        }
        result += minSwapSort(dp, map);
        
    }
    return result;
}

private int minSwapSort(int[] dp, Map<Integer, Integer> map) {
    int result = 0;
    int[] temp = dp.clone();
    Arrays.sort(dp);
    for (int i = 0; i < dp.length; i++) {
        if (temp[i] == dp[i]) {
            continue;
        }
        map.put(temp[i], map.get(dp[i]));
        swap(temp, i, map.get(dp[i]));
        result++;
    }
    return result;
}

private void swap(int[] nums, int x, int y) {
    int temp = nums[x];
    nums[x] = nums[y];
    nums[y] = temp;
}
```

Time Complexity: O(n)

Space Complexity: O(n)