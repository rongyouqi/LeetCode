## [LeetCode 2472](https://leetcode.com/problems/maximum-number-of-non-overlapping-palindrome-substrings/) Maximum Number of Non-overlapping Palindrome Substrings (hard)

- You are given a string `s` and a **positive** integer `k`.
- Select a set of **non-overlapping** substrings from the string `s` that satisfy the following conditions:
    -   The **length** of each substring is **at least** `k`.
    -   Each substring is a **palindrome**.
- Return _the **maximum** number of substrings in an optimal selection_.
- A **substring** is a contiguous sequence of characters within a string.
- **Example 1:**
    - **Input:** s = "abaccdbbd", k = 3
    - **Output:** 2
    - **Explanation:** We can select the substrings underlined in s = "**aba**cc**dbbd**". Both "aba" and "dbbd" are palindromes and have a length of at least k = 3.
        - It can be shown that we cannot find a selection with more than two valid substrings.
- **Example 2:**
    - **Input:** s = "adbcda", k = 2
    - **Output:** 0
    - **Explanation:** There is no palindrome substring of length at least 2 in the string.
- **Constraints:**
    -   `1 <= k <= s.length <= 2000`
    -   `s` consists of lowercase English letters.

### Solution

```java
public int maxPalindromes(String s, int k) {
    int result = 0, index = 0;
    while (index <= s.length() - k) {
        if (isPalindrome(s, index, index + k - 1)) {
            result++;
            index += k;
        } else if (index < s.length() - k && isPalindrome(s, index, index + k)) {
            result++;
            index += k + 1;
        } else {
            index++;
        }
    }
    return result;
}

private boolean isPalindrome(String s, int left, int right) {
    while (left < right) {
        if (s.charAt(left++) != s.charAt(right--)) {
            return false;
        }
    }
    return true;
}
```

Time Complexity: O(n^2)

Space Complexity: O(1)