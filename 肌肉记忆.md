# 肌肉记忆

## 1. Sorting Algorithms

### [LeetCode 912](https://leetcode.com/problems/sort-an-array/) Sort an Array

#### Solution 1: bubble sort (time limit exceeded)

```java
public int[] sortArray(int[] nums) {
    if (nums == null || nums.length <= 1) {
        return nums;
    }
    for (int i = 0; i < nums.length - 1; i++) {
        for (int j = 0; j < nums.length - 1 - i; j++) {
            if (nums[j] > nums[j + 1]) {
                swap(nums, j, j + 1);
            }
        }
    }
    return nums;
}

private void swap(int[] nums, int x, int y) {
    int temp = nums[x];
    nums[x] = nums[y];
    nums[y] = temp;
}
```

Time Complexity: O(n^2)

Space Complexity: O(1)

#### Solution 2: selection sort (time limit exceeded)

```java
public int[] sortArray(int[] nums) {
    if (nums == null || nums.length <= 1) {
        return nums;
    }
    for (int i = 0; i < nums.length - 1; i++) {
        int min = i;
        for (int j = i + 1; j < nums.length; j++) {
            if (nums[j] < nums[min]) {
                min = j;
            }
        }
        swap(nums, i, min);
    }
    return nums;
}

private void swap(int[] nums, int x, int y) {
    int temp = nums[x];
    nums[x] = nums[y];
    nums[y] = temp;
}
```

Time Complexity: O(n^2)

Space Complexity: O(1)

#### Solution 3: merge sort

```java
public int[] sortArray(int[] nums) {
    if (nums == null || nums.length <= 1) {
        return nums;
    }
    int[] helper = new int[nums.length];
    mergeSort(nums, helper, 0, nums.length - 1);
    return nums;
}

private void mergeSort(int[] nums, int[] helper, int left, int right) {
    if (left >= right) {
        return;
    }
    int mid = left + (right - left) / 2;
    mergeSort(nums, helper, left, mid);
    mergeSort(nums, helper, mid + 1, right);
    merge(nums, helper, left, mid, right);
}

private void merge(int[] nums, int[] helper, int left, int mid, int right) {
    for (int i = left; i <= right; i++) {
        helper[i] = nums[i];
    }
    int leftIndex = left, rightIndex = mid + 1;
    while (leftIndex <= mid && rightIndex <= right) {
        if (helper[leftIndex] <= helper[rightIndex]) {
            nums[left++] = helper[leftIndex++];
        } else {
            nums[left++] = helper[rightIndex++];
            // result += mid + 1 - leftIndex; // 飞鸟回笼
        }
    }
    while (leftIndex <= mid) {
        nums[left++] = helper[leftIndex++];
    }
}
```

Time Complexity: O(nlogn)

Space Complexity: O(n)

#### Solution 4: quick sort

```java
public int[] sortArray(int[] nums) {
    if (nums == null || nums.length <= 1) {
        return nums;
    }
    quickSort(nums, 0, nums.length - 1);
    return nums;
}

private void quickSort(int[] nums, int left, int right) {
    if (left >= right) {
        return;
    }
    int pivotPos = partition(nums, left, right);
    quickSort(nums, left, pivotPos - 1);
    quickSort(nums, pivotPos + 1, right);
}

private int partition(int[] nums, int left, int right) {
    int pivotIndex = left + (int)(Math.random() * (right - left + 1));
    int pivot = nums[pivotIndex];
    swap(nums, pivotIndex, right);
    int leftBound = left;
    int rightBound = right - 1;
    while (leftBound <= rightBound) {
        if (nums[leftBound] < pivot) {
            leftBound++;
        } else if (nums[rightBound] >= pivot) {
            rightBound--;
        } else {
            swap(nums, leftBound++, rightBound--);
        }
    }
    swap(nums, leftBound, right);
    return leftBound;
}

private void swap(int[] nums, int x, int y) {
    int temp = nums[x];
    nums[x] = nums[y];
    nums[y] = temp;
}
```

Time Complexity: worst case O(n^2), average case O(nlogn)

Space Complexity: worst case O(n), average case O(logn)

### [LeetCode 75](https://leetcode.com/problems/sort-colors/) Sort Colors (medium)

- Given an array `nums` with `n` objects colored red, white, or blue, sort them **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
- We will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.
- You must solve this problem without using the library's sort function.
- **Example 1:**
    - **Input:** nums = [2,0,2,1,1,0]
    - **Output:** [0,0,1,1,2,2]
- **Example 2:**
    - **Input:** nums = [2,0,1]
    - **Output:** [0,1,2]
- **Constraints:**
    -   `n == nums.length`
    -   `1 <= n <= 300`
    -   `nums[i]` is either `0`, `1`, or `2`.
- **Follow up:** Could you come up with a one-pass algorithm using only constant extra space?

#### Solution

```java
public void sortColors(int[] nums) {
    if (nums == null || nums.length < 2) {
        return;
    }
    int zero = 0, one = 0, two = nums.length - 1;
    while (one <= two) {
        if (nums[one] == 0) {
            swap(nums, zero++, one++);
        } else if (nums[one] == 1) {
            one++;
        } else {
            swap(nums, one, two--);
        }
    }
}

private void swap(int[] nums, int x, int y) {
    int temp = nums[x];
    nums[x] = nums[y];
    nums[y] = temp;
}
```

Time Complexity: O(n)

Space Complexity: O(1)

### [LeetCode 539](https://leetcode.com/problems/minimum-time-difference/) Minimum Time Difference (medium)

- Given a list of 24-hour clock time points in **"HH:MM"** format, return _the minimum **minutes** difference between any two time-points in the list_.
- **Example 1:**
    - **Input:** timePoints = ["23:59","00:00"]
    - **Output:** 1
- **Example 2:**
    - **Input:** timePoints = ["00:00","23:59","00:00"]
    - **Output:** 0
- **Constraints:**
    -   `2 <= timePoints.length <= 2 * 10^4`
    -   `timePoints[i]` is in the format **"HH:MM"**.

#### Solution: bucket sort

```java
public int findMinDifference(List<String> timePoints) {
    boolean[] visited = new boolean[24 * 60];
    for (String time : timePoints) {
        int h = Integer.parseInt(time.substring(0, 2));
        int m = Integer.parseInt(time.substring(3));
        if (visited[h * 60 + m]) {
            return 0;
        }
        visited[h * 60 + m] = true;
    }
    int first = 0, last = 24 * 60 - 1;
    while (!visited[first]) {
        first++;
    }
    while (!visited[last]) {
        last--;
    }
    int index = first, result = 24 * 60 - last + first;
    for (int i = first + 1; i <= last; i++) {
        if (visited[i]) {
            result = Math.min(result, i - index);
            index = i;
        }
    }
    return result;
}
```

Time Complexity: O(n)

Space Complexity: O(24 * 60) = O(1)

## 2. Reverse Linked List (easy)

[LeetCode 206](https://leetcode.com/problems/reverse-linked-list/)

### Solution 1: iterative

```java
public ListNode reverseList(ListNode head) {
    // corner case
    if (head == null) {
        return null;
    }
    ListNode previous = null;
    ListNode current = head;
    ListNode next = null;
    while (current != null) {
        next = current.next; // store next node
        current.next = previous; // reverse
        previous = current; // previous moves one step
        current = next; // next moves one step
    }
    return previous;
}
```

Time Complexity: O(n)

Space Complexity: O(1)

### Solution 2: recursive

```java
public ListNode reverseList(ListNode head) {
    // base case
    if (head == null || head.next == null) {
        return head;
    }
    // recursive step
    ListNode newHead = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
}
```

Time Complexity: O(n)

Space Complexity: O(n)

## 3. Binary Tree Traversal

### Preorder 根左右 [LeetCode 144](https://leetcode.com/problems/binary-tree-preorder-traversal/)

#### Solution 1: recursive

```java
public List<Integer> preorderTraversal(TreeNode root) {
    // todo
}
```

Time Complexity: O()

Space Complexity: O()

#### Solution 2: iterative

```java
public List<Integer> preorderTraversal(TreeNode root) {
    // todo
}
```

Time Complexity: O()

Space Complexity: O()

### Inorder 左根右 [LeetCode 94](https://leetcode.com/problems/binary-tree-inorder-traversal/)

#### Solution 1: recursive

```java
public List<Integer> inorderTraversal(TreeNode root) {
    // todo
}
```

Time Complexity: O()

Space Complexity: O()

#### Solution 2: iterative

```java
public List<Integer> inorderTraversal(TreeNode root) {
    // todo
}
```

Time Complexity: O()

Space Complexity: O()

### Postorder 左右根 [LeetCode 145](https://leetcode.com/problems/binary-tree-postorder-traversal/)

#### Solution 1: recursive

```java
public List<Integer> postorderTraversal(TreeNode root) {
    // todo
}
```

Time Complexity: O()

Space Complexity: O()

#### Solution 2: iterative

```java
public List<Integer> postorderTraversal(TreeNode root) {
    // todo
}
```

Time Complexity: O()

Space Complexity: O()

### Level Order

#### [LeetCode 297](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/) Serialize and Deserialize Binary Tree (hard)

```java
public String serialize(TreeNode root) {
    if (root == null) {
        return "#";
    }
    StringBuilder sb = new StringBuilder();
    Queue<TreeNode> q = new LinkedList<>(); // LinkedList to store null;
    q.offer(root);
    while (!q.isEmpty()) {
        TreeNode node = q.poll();
        if (node == null) {
            sb.append("# ");
            continue;
        }
        sb.append(node.val + " ");
        q.offer(node.left);
        q.offer(node.right);
    }
    return sb.toString();
}

public TreeNode deserialize(String data) {
    if (data == "#") {
        return null;
    }
    String[] array = data.split(" ");
    TreeNode root = new TreeNode(Integer.parseInt(array[0]));
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);
    for (int i = 1; i < array.length; i++) {
        TreeNode parent = q.poll();
        if (!array[i].equals("#")) {
            TreeNode left = new TreeNode(Integer.parseInt(array[i]));
            parent.left = left;
            q.offer(left);
        }
        i++;
        if (!array[i].equals("#")) {
            TreeNode right = new TreeNode(Integer.parseInt(array[i]));
            parent.right = right;
            q.offer(right);
        }
    }
    return root;
}
```

#### [LeetCode 102](https://leetcode.com/problems/binary-tree-level-order-traversal/) Binary Tree Level Order Traversal (medium)

- Given the `root` of a binary tree, return _the level order traversal of its nodes' values_. (i.e., from left to right, level by level).
- **Example 1:**
    - <img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" style="zoom: 67%;" />
    - **Input:** root = `[3,9,20,null,null,15,7]`
    - **Output:** `[[3],[9,20],[15,7]]`
- **Example 2:**
    - **Input:** root = `[1]`
    - **Output:** `[[1]]`
- **Example 3:**
    - **Input:** root = `[]`
    - **Output:** `[]`
- **Constraints:**
    -   The number of nodes in the tree is in the range `[0, 2000]`.
    -   `-1000 <= Node.val <= 1000`

##### Solution 1: bfs

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    Queue<TreeNode> q = new ArrayDeque<>();
    q.offer(root);
    while (!q.isEmpty()) {
        List<Integer> level = new ArrayList<>();
        int size = q.size();
        for (int i = 0; i < size; i++) {
            TreeNode node = q.poll();
            level.add(node.val);
            if (node.left != null) {
                q.offer(node.left);
            }
            if (node.right != null) {
                q.offer(node.right);
            }
        }
        result.add(level);
    }
    return result;
}
```

Time Complexity: O(n)

Space Complexity: O(width)

##### Solution 2: dfs

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    dfs(root, 0, result);
    return result;
}

private void dfs(TreeNode root, int level, List<List<Integer>> result) {
    if (root == null) {
        return;
    }
    if (result.size() == level) {
        result.add(new ArrayList<>());
    }
    result.get(level).add(root.val);
    dfs(root.left, level + 1, result);
    dfs(root.right, level + 1, result);
}
```

Time Complexity: O(n)

Space Complexity: O(height)

#### [LeetCode 103](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/) Binary Tree Zigzag Level Order Traversal (medium)

- Given the `root` of a binary tree, return _the zigzag level order traversal of its nodes' values_. (i.e., from left to right, then right to left for the next level and alternate between).
- **Example 1:**
    - <img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" style="zoom:67%;" />
    - **Input:** root = `[3,9,20,null,null,15,7]`
    - **Output:** `[[3],[20,9],[15,7]]`
- **Example 2:**
    - **Input:** root = `[1]`
    - **Output:** `[[1]]`
- **Example 3:**
    - **Input:** root = `[]`
    - **Output:** `[]`
- **Constraints:**
    -   The number of nodes in the tree is in the range `[0, 2000]`.
    -   `-100 <= Node.val <= 100`

##### Solution 1: bfs

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    Deque<TreeNode> dq = new ArrayDeque<>();
    dq.offer(root);
    int depth = 0;
    while (!dq.isEmpty()) {
        List<Integer> level = new ArrayList<>();
        int size = dq.size();
        for (int i = 0; i < size; i++) {
            if (depth % 2 == 0) {
                TreeNode node = dq.pollFirst();
                level.add(node.val);
                if (node.left != null) {
                    dq.offerLast(node.left);
                }
                if (node.right != null) {
                    dq.offerLast(node.right);
                }
            } else {
                TreeNode node = dq.pollLast();
                level.add(node.val);
                if (node.right != null) {
                    dq.offerFirst(node.right);
                }
                if (node.left != null) {
                    dq.offerFirst(node.left);
                }
            }
        }
        result.add(level);
        depth++;
    }
    return result;
}
```

Time Complexity: O(n)

Space Complexity: O(width)

##### Solution 2: dfs

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    dfs(root, 0, result);
    return result;
}

private void dfs(TreeNode root, int depth, List<List<Integer>> result) {
    if (root == null) {
        return;
    }
    if (depth == result.size()) {
        List<Integer> level = new ArrayList<>();
        level.add(root.val);
        result.add(level);
    } else {
        if (depth % 2 == 0) {
            result.get(depth).add(root.val);
        } else {
            result.get(depth).add(0, root.val);
        }
    }
    dfs(root.left, depth + 1, result);
    dfs(root.right, depth + 1, result);
}
```

Time Complexity: O(n)

Space Complexity: O(height)

#### [LeetCode 107](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/) Binary Tree Level Order Traversal II (medium)

- Given the `root` of a binary tree, return _the bottom-up level order traversal of its nodes' values_. (i.e., from left to right, level by level from leaf to root).
- **Example 1:**
    - <img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" style="zoom:67%;" />
    - **Input:** root = `[3,9,20,null,null,15,7]`
    - **Output:** `[[15,7],[9,20],[3]]`
- **Example 2:**
    - **Input:** root = `[1]`
    - **Output:** `[[1]]`
- **Example 3:**
    - **Input:** root = `[]`
    - **Output:** `[]`
- **Constraints:**
    -   The number of nodes in the tree is in the range `[0, 2000]`.
    -   `-1000 <= Node.val <= 1000`

##### Solution 1: bfs

```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    Queue<TreeNode> q = new ArrayDeque<>();
    q.offer(root);
    while (!q.isEmpty()) {
        List<Integer> level = new ArrayList<>();
        int size = q.size();
        for (int i = 0; i < size; i++) {
            TreeNode node = q.poll();
            level.add(node.val);
            if (node.left != null) {
                q.offer(node.left);
            }
            if (node.right != null) {
                q.offer(node.right);
            }
        }
        result.add(0, level);
    }
    return result;
}
```

Time Complexity: O(n)

Space Complexity: O(width)

##### Solution 2: dfs

```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    dfs(root, 0, result);
    return result;
}

private void dfs(TreeNode root, int depth, List<List<Integer>> result) {
    if (root == null) {
        return;
    }
    if (depth == result.size()) {
        List<Integer> level = new ArrayList<>();
        level.add(root.val);
        result.add(0, level);
    } else {
        result.get(result.size() - depth - 1).add(root.val);
    }
    dfs(root.left, depth + 1, result);
    dfs(root.right, depth + 1, result);
}
```

Time Complexity: O(n)

Space Complexity: O(height)

#### [LeetCode 429](https://leetcode.com/problems/n-ary-tree-level-order-traversal/) N-ary Tree Level Order Traversal (medium)

- Given an n-ary tree, return the _level order_ traversal of its nodes' values.
- _Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples)._
- **Example 1:**
    - <img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" style="zoom:50%;" />
    - **Input:** root = `[1,null,3,2,4,null,5,6]`
    - **Output:** `[[1],[3,2,4],[5,6]]`
- **Example 2:**
    - <img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" style="zoom:50%;" />
    - **Input:** root = `[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]`
    - **Output:** `[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]`
- **Constraints:**
    -   The height of the n-ary tree is less than or equal to `1000`
    -   The total number of nodes is between `[0, 10^4]`

##### Solution: bfs

```java
public List<List<Integer>> levelOrder(Node root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    Queue<Node> q = new ArrayDeque<>();
    q.offer(root);
    while (!q.isEmpty()) {
        List<Integer> level = new ArrayList<>();
        int size = q.size();
        for (int i = 0; i < size; i++) {
            Node node = q.poll();
            level.add(node.val);
            for (Node child : node.children) {
                q.offer(child);
            }
        }
        result.add(level);
    }
    return result;
}
```

Time Complexity: O(n)

Space Complexity: O(width)

### Vertical Order

#### [LeetCode 314](https://leetcode.com/problems/binary-tree-vertical-order-traversal/) Binary Tree Vertical Order Traversal (medium)

- Given the `root` of a binary tree, return _**the vertical order traversal** of its nodes' values_. (i.e., from top to bottom, column by column).
- If two nodes are in the same row and column, the order should be from **left to right**.
- **Example 1:**
    - <img src="https://assets.leetcode.com/uploads/2021/01/28/vtree1.jpg" style="zoom:67%;" />
    - **Input:** root = `[3,9,20,null,null,15,7]`
    - **Output:** `[[9],[3,15],[20],[7]]`
- **Example 2:**
    - <img src="https://assets.leetcode.com/uploads/2021/01/28/vtree2-1.jpg" style="zoom:67%;" />
    - **Input:** root = `[3,9,8,4,0,1,7]`
    - **Output:** `[[4],[9],[3,0,1],[8],[7]]`
- **Example 3:**
    - <img src="https://assets.leetcode.com/uploads/2021/01/28/vtree2.jpg" style="zoom:67%;" />
    - **Input:** root = `[3,9,8,4,0,1,7,null,null,null,2,5]`
    - **Output:** `[[4],[9,5],[3,0,1],[8,2],[7]]`
- **Constraints:**
    -   The number of nodes in the tree is in the range `[0, 100]`.
    -   `-100 <= Node.val <= 100`

##### Solution 1: bfs

```java
public List<List<Integer>> verticalOrder(TreeNode root) {
	List<List<Integer>> result = new ArrayList<>();
	if (root == null) {
		return result;
	}
	Map<Integer, List<Integer>> map = new HashMap<>();
	Queue<Pair<TreeNode, Integer>> queue = new ArrayDeque<>();
	queue.offer(new Pair(root, 0));
	int min = 0, max = 0;
	while (!queue.isEmpty()) {
		Pair<TreeNode, Integer> pair = queue.poll();
		TreeNode node = pair.getKey();
		int column = pair.getValue();
		if (node != null) {
			map.computeIfAbsent(column, k -> new ArrayList<>()).add(node.val);
			min = Math.min(min, column);
			max = Math.max(max, column);
			queue.offer(new Pair(node.left, column - 1));
			queue.offer(new Pair(node.right, column + 1));
		}
	}
	for (int i = min; i <= max; i++) {
		result.add(map.get(i));
	}
	return result;
}
```

Time Complexity: O(n)

Space Complexity: O(width)

##### Solution 2: dfs

```java
public List<List<Integer>> verticalOrder(TreeNode root) {
	List<List<Integer>> result = new ArrayList<>();
	if (root == null) {
		return result;
	}
    Map<Integer, List<Pair<Integer, Integer>>> map = new HashMap<>();
    int[] minmax = new int[2];
    dfs(root, 0, 0, minmax, map);
    for (int i = minmax[0]; i <= minmax[1]; i++) {
		Collections.sort(map.get(i), (a, b) -> a.getKey() - b.getKey());
        List<Integer> column = new ArrayList<>();
        for (Pair<Integer, Integer> p : map.get(i)) {
            column.add(p.getValue());
        }
        result.add(column);
	}
    return result;
}

private void dfs(TreeNode root, int row, int column, int[] minmax, Map<Integer, List<Pair<Integer, Integer>>> map) {
    if (root == null) {
        return;
    }
    map.computeIfAbsent(column, k -> new ArrayList<>()).add(new Pair(row, root.val));
	minmax[0] = Math.min(minmax[0], column);
	minmax[1] = Math.max(minmax[1], column);
    dfs(root.left, row + 1, column - 1, minmax, map);
    dfs(root.right, row + 1, column + 1, minmax, map);
}
```

Time Complexity: O(nlogn)

Space Complexity: O(height)

#### [LeetCode 987](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/) Vertical Order Traversal of a Binary Tree (hard)

- Given the `root` of a binary tree, calculate the **vertical order traversal** of the binary tree.
- For each node at position `(row, col)`, its left and right children will be at positions `(row + 1, col - 1)` and `(row + 1, col + 1)` respectively. The root of the tree is at `(0, 0)`.
- The **vertical order traversal** of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.
- Return _the **vertical order traversal** of the binary tree_.
- **Example 1:**
    - ![](https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg)
    - **Input:** root = `[3,9,20,null,null,15,7]`
    - **Output:** `[[9],[3,15],[20],[7]]`
    - **Explanation:**
        - Column -1: Only node 9 is in this column.
        - Column 0: Nodes 3 and 15 are in this column in that order from top to bottom.
        - Column 1: Only node 20 is in this column.
        - Column 2: Only node 7 is in this column.
- **Example 2:**
    - ![](https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg)
    - **Input:** root = `[1,2,3,4,5,6,7]`
    - **Output:** `[[4],[2],[1,5,6],[3],[7]]`
    - **Explanation:**
        - Column -2: Only node 4 is in this column.
        - Column -1: Only node 2 is in this column.
        - Column 0: Nodes 1, 5, and 6 are in this column. 1 is at the top, so it comes first. 5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.
        - Column 1: Only node 3 is in this column.
        - Column 2: Only node 7 is in this column.
- **Example 3:**
    - ![](https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg)
    - **Input:** root = `[1,2,3,4,6,5,7]`
    - **Output:** `[[4],[2],[1,5,6],[3],[7]]`
    - **Explanation:**
        - This case is the exact same as example 2, but with nodes 5 and 6 swapped.
        - Note that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.
- **Constraints:**
    -   The number of nodes in the tree is in the range `[1, 1000]`.
    -   `0 <= Node.val <= 1000`

##### Solution 1: bfs

```java
public List<List<Integer>> verticalTraversal(TreeNode root) {
	List<List<Integer>> result = new ArrayList<>();
	if (root == null) {
		return result;
	}
	Map<Integer, List<Pair<Integer, Integer>>> map = new HashMap<>();
	Queue<Pair<TreeNode, int[]>> queue = new ArrayDeque<>();
	queue.offer(new Pair(root, new int[]{0, 0}));
	int min = 0, max = 0;
	while (!queue.isEmpty()) {
		Pair<TreeNode, int[]> pair = queue.poll();
		TreeNode node = pair.getKey();
        int row = pair.getValue()[0];
		int column = pair.getValue()[1];
		if (node != null) {
			map.computeIfAbsent(column, k -> new ArrayList<>()).add(new Pair(row, node.val));
			min = Math.min(min, column);
			max = Math.max(max, column);
			queue.offer(new Pair(node.left, new int[]{row + 1, column - 1}));
			queue.offer(new Pair(node.right, new int[]{row + 1, column + 1}));
		}
	}
	for (int i = min; i <= max; i++) {
		Collections.sort(map.get(i), (a, b) -> a.getKey() == b.getKey() ? a.getValue() - b.getValue() : a.getKey() - b.getKey());
        List<Integer> column = new ArrayList<>();
        for (Pair<Integer, Integer> p : map.get(i)) {
            column.add(p.getValue());
        }
        result.add(column);
	}
	return result;
}
```

Time Complexity: O(nlog(width))

Space Complexity: O(width)

##### Solution 2: dfs

```java
public List<List<Integer>> verticalTraversal(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
	if (root == null) {
		return result;
	}
    Map<Integer, List<Pair<Integer, Integer>>> map = new HashMap<>();
    int[] minmax = new int[2];
    dfs(root, 0, 0, minmax, map);
    for (int i = minmax[0]; i <= minmax[1]; i++) {
		Collections.sort(map.get(i), (a, b) -> a.getKey() == b.getKey() ? a.getValue() - b.getValue() : a.getKey() - b.getKey());
        List<Integer> column = new ArrayList<>();
        for (Pair<Integer, Integer> p : map.get(i)) {
            column.add(p.getValue());
        }
        result.add(column);
	}
    return result;
}

private void dfs(TreeNode root, int row, int column, int[] minmax, Map<Integer, List<Pair<Integer, Integer>>> map) {
    if (root == null) {
        return;
    }
    map.computeIfAbsent(column, k -> new ArrayList<>()).add(new Pair(row, root.val));
	minmax[0] = Math.min(minmax[0], column);
	minmax[1] = Math.max(minmax[1], column);
    dfs(root.left, row + 1, column - 1, minmax, map);
    dfs(root.right, row + 1, column + 1, minmax, map);
}
```

Time Complexity: O(nlogn)

Space Complexity: O(height)


## 4. Priority Queue

```java
PriorityQueue<Integer> minHeap = new PriorityQueue<>();
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
```



## 5. Implement Hashmap

todo

## 6. Implement LRU Cache

todo

