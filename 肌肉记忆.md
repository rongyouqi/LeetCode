# 肌肉记忆

## 1. Sorting Algorithms

### [LeetCode 912](https://leetcode.com/problems/sort-an-array/) Sort an Array

#### Solution 1: bubble sort (time limit exceeded)

```java
public int[] sortArray(int[] nums) {
    if (nums == null || nums.length <= 1) {
        return nums;
    }
    for (int i = 0; i < nums.length - 1; i++) {
        for (int j = 0; j < nums.length - 1 - i; j++) {
            if (nums[j] > nums[j + 1]) {
                swap(nums, j, j + 1);
            }
        }
    }
    return nums;
}

private void swap(int[] nums, int x, int y) {
    int temp = nums[x];
    nums[x] = nums[y];
    nums[y] = temp;
}
```

Time Complexity: O(n^2)

Space Complexity: O(1)

#### Solution 2: selection sort (time limit exceeded)

```java
public int[] sortArray(int[] nums) {
    if (nums == null || nums.length <= 1) {
        return nums;
    }
    for (int i = 0; i < nums.length - 1; i++) {
        int min = i;
        for (int j = i + 1; j < nums.length; j++) {
            if (nums[j] < nums[min]) {
                min = j;
            }
        }
        swap(nums, i, min);
    }
    return nums;
}

private void swap(int[] nums, int x, int y) {
    int temp = nums[x];
    nums[x] = nums[y];
    nums[y] = temp;
}
```

Time Complexity: O(n^2)

Space Complexity: O(1)

#### Solution 3: merge sort

```java
public int[] sortArray(int[] nums) {
    if (nums == null || nums.length <= 1) {
        return nums;
    }
    int[] helper = new int[nums.length];
    mergeSort(nums, helper, 0, nums.length - 1);
    return nums;
}

private void mergeSort(int[] nums, int[] helper, int left, int right) {
    if (left >= right) {
        return;
    }
    int mid = left + (right - left) / 2;
    mergeSort(nums, helper, left, mid);
    mergeSort(nums, helper, mid + 1, right);
    merge(nums, helper, left, mid, right);
}

private void merge(int[] nums, int[] helper, int left, int mid, int right) {
    for (int i = left; i <= right; i++) {
        helper[i] = nums[i];
    }
    int leftIndex = left, rightIndex = mid + 1;
    while (leftIndex <= mid && rightIndex <= right) {
        if (helper[leftIndex] <= helper[rightIndex]) {
            nums[left++] = helper[leftIndex++];
        } else {
            nums[left++] = helper[rightIndex++];
            // result += mid + 1 - leftIndex; // 飞鸟回笼
        }
    }
    while (leftIndex <= mid) {
        nums[left++] = helper[leftIndex++];
    }
}
```

Time Complexity: O(nlogn)

Space Complexity: O(n)

#### Solution 4: quick sort

```java
public int[] sortArray(int[] nums) {
    if (nums == null || nums.length <= 1) {
        return nums;
    }
    quickSort(nums, 0, nums.length - 1);
    return nums;
}

private void quickSort(int[] nums, int left, int right) {
    if (left >= right) {
        return;
    }
    int pivotPos = partition(nums, left, right);
    quickSort(nums, left, pivotPos - 1);
    quickSort(nums, pivotPos + 1, right);
}

private int partition(int[] nums, int left, int right) {
    int pivotIndex = left + (int)(Math.random() * (right - left + 1));
    int pivot = nums[pivotIndex];
    swap(nums, pivotIndex, right);
    int leftBound = left;
    int rightBound = right - 1;
    while (leftBound <= rightBound) {
        if (nums[leftBound] < pivot) {
            leftBound++;
        } else if (nums[rightBound] >= pivot) {
            rightBound--;
        } else {
            swap(nums, leftBound++, rightBound--);
        }
    }
    swap(nums, leftBound, right);
    return leftBound;
}

private void swap(int[] nums, int x, int y) {
    int temp = nums[x];
    nums[x] = nums[y];
    nums[y] = temp;
}
```

Time Complexity: worst case O(n^2), average case O(nlogn)

Space Complexity: worst case O(n), average case O(logn)

### [LeetCode 75](https://leetcode.com/problems/sort-colors/) Sort Colors (medium)

- Given an array `nums` with `n` objects colored red, white, or blue, sort them **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
- We will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.
- You must solve this problem without using the library's sort function.
- **Example 1:**
    - **Input:** nums = [2,0,2,1,1,0]
    - **Output:** [0,0,1,1,2,2]
- **Example 2:**
    - **Input:** nums = [2,0,1]
    - **Output:** [0,1,2]
- **Constraints:**
    -   `n == nums.length`
    -   `1 <= n <= 300`
    -   `nums[i]` is either `0`, `1`, or `2`.
- **Follow up:** Could you come up with a one-pass algorithm using only constant extra space?

#### Solution

```java
public void sortColors(int[] nums) {
    if (nums == null || nums.length < 2) {
        return;
    }
    int zero = 0, one = 0, two = nums.length - 1;
    while (one <= two) {
        if (nums[one] == 0) {
            swap(nums, zero++, one++);
        } else if (nums[one] == 1) {
            one++;
        } else {
            swap(nums, one, two--);
        }
    }
}

private void swap(int[] nums, int x, int y) {
    int temp = nums[x];
    nums[x] = nums[y];
    nums[y] = temp;
}
```

Time Complexity: O(n)

Space Complexity: O(1)

### [LeetCode 539](https://leetcode.com/problems/minimum-time-difference/) Minimum Time Difference (medium)

- Given a list of 24-hour clock time points in **"HH:MM"** format, return _the minimum **minutes** difference between any two time-points in the list_.
- **Example 1:**
    - **Input:** timePoints = ["23:59","00:00"]
    - **Output:** 1
- **Example 2:**
    - **Input:** timePoints = ["00:00","23:59","00:00"]
    - **Output:** 0
- **Constraints:**
    -   `2 <= timePoints.length <= 2 * 10^4`
    -   `timePoints[i]` is in the format **"HH:MM"**.

#### Solution: bucket sort

```java
public int findMinDifference(List<String> timePoints) {
    boolean[] visited = new boolean[24 * 60];
    for (String time : timePoints) {
        int h = Integer.parseInt(time.substring(0, 2));
        int m = Integer.parseInt(time.substring(3));
        if (visited[h * 60 + m]) {
            return 0;
        }
        visited[h * 60 + m] = true;
    }
    int first = 0, last = 24 * 60 - 1;
    while (!visited[first]) {
        first++;
    }
    while (!visited[last]) {
        last--;
    }
    int index = first, result = 24 * 60 - last + first;
    for (int i = first + 1; i <= last; i++) {
        if (visited[i]) {
            result = Math.min(result, i - index);
            index = i;
        }
    }
    return result;
}
```

Time Complexity: O(n)

Space Complexity: O(24 * 60) = O(1)

## 2. Reverse Linked List (easy)

[LeetCode 206](https://leetcode.com/problems/reverse-linked-list/)

### Solution 1: iterative

```java
public ListNode reverseList(ListNode head) {
    // corner case
    if (head == null) {
        return null;
    }
    ListNode previous = null;
    ListNode current = head;
    ListNode next = null;
    while (current != null) {
        next = current.next; // store next node
        current.next = previous; // reverse
        previous = current; // previous moves one step
        current = next; // next moves one step
    }
    return previous;
}
```

Time Complexity: O(n)

Space Complexity: O(1)

### Solution 2: recursive

```java
public ListNode reverseList(ListNode head) {
    // base case
    if (head == null || head.next == null) {
        return head;
    }
    // recursive step
    ListNode newHead = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
}
```

Time Complexity: O(n)

Space Complexity: O(n)

## 3. Binary Tree Traversal

### Preorder 根左右 [LeetCode 144](https://leetcode.com/problems/binary-tree-preorder-traversal/)

#### Solution 1: recursive

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    helper(root, result);
    return result;
}
private void helper(TreeNode root, List<Integer> result) {
    if (root == null) {
        return;
    }
    result.add(root.val);
    helper(root.left, result);
    helper(root.right, result);
}
```

Time Complexity: O(n)

Space Complexity: O(height)

#### Solution 2: iterative

```java
public List<Integer> preorderTraversal(TreeNode root) {
    // todo
}
```

Time Complexity: O()

Space Complexity: O()

### Inorder 左根右 [LeetCode 94](https://leetcode.com/problems/binary-tree-inorder-traversal/)

#### Solution 1: recursive

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    helper(root, result);
    return result;
}
private void helper(TreeNode root, List<Integer> result) {
    if (root == null) {
        return;
    }
    helper(root.left, result);
    result.add(root.val);
    helper(root.right, result);
}
```

Time Complexity: O(n)

Space Complexity: O(height)

#### Solution 2: iterative

```java
public List<Integer> inorderTraversal(TreeNode root) {
    // todo
}
```

Time Complexity: O()

Space Complexity: O()

### Postorder 左右根 [LeetCode 145](https://leetcode.com/problems/binary-tree-postorder-traversal/)

#### Solution 1: recursive

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    helper(root, result);
    return result;
}
private void helper(TreeNode root, List<Integer> result) {
    if (root == null) {
        return;
    }
    helper(root.left, result);
    helper(root.right, result);
    result.add(root.val);
}
```

Time Complexity: O(n)

Space Complexity: O(height)

#### Solution 2: iterative

```java
public List<Integer> postorderTraversal(TreeNode root) {
    // todo
}
```

Time Complexity: O()

Space Complexity: O()

### Level Order

#### [LeetCode 297](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/) Serialize and Deserialize Binary Tree (hard)

```java
public String serialize(TreeNode root) {
    if (root == null) {
        return "#";
    }
    StringBuilder sb = new StringBuilder();
    Queue<TreeNode> q = new LinkedList<>(); // LinkedList to store null;
    q.offer(root);
    while (!q.isEmpty()) {
        TreeNode node = q.poll();
        if (node == null) {
            sb.append("# ");
            continue;
        }
        sb.append(node.val + " ");
        q.offer(node.left);
        q.offer(node.right);
    }
    return sb.toString();
}

public TreeNode deserialize(String data) {
    if (data == "#") {
        return null;
    }
    String[] array = data.split(" ");
    TreeNode root = new TreeNode(Integer.parseInt(array[0]));
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);
    for (int i = 1; i < array.length; i++) {
        TreeNode parent = q.poll();
        if (!array[i].equals("#")) {
            TreeNode left = new TreeNode(Integer.parseInt(array[i]));
            parent.left = left;
            q.offer(left);
        }
        i++;
        if (!array[i].equals("#")) {
            TreeNode right = new TreeNode(Integer.parseInt(array[i]));
            parent.right = right;
            q.offer(right);
        }
    }
    return root;
}
```

#### [LeetCode 102](https://leetcode.com/problems/binary-tree-level-order-traversal/) Binary Tree Level Order Traversal (medium)

- Given the `root` of a binary tree, return _the level order traversal of its nodes' values_. (i.e., from left to right, level by level).
- **Example 1:**
    - <img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" style="zoom: 67%;" />
    - **Input:** root = `[3,9,20,null,null,15,7]`
    - **Output:** `[[3],[9,20],[15,7]]`
- **Example 2:**
    - **Input:** root = `[1]`
    - **Output:** `[[1]]`
- **Example 3:**
    - **Input:** root = `[]`
    - **Output:** `[]`
- **Constraints:**
    -   The number of nodes in the tree is in the range `[0, 2000]`.
    -   `-1000 <= Node.val <= 1000`

##### Solution 1: bfs

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    Queue<TreeNode> q = new ArrayDeque<>();
    q.offer(root);
    while (!q.isEmpty()) {
        List<Integer> level = new ArrayList<>();
        int size = q.size();
        for (int i = 0; i < size; i++) {
            TreeNode node = q.poll();
            level.add(node.val);
            if (node.left != null) {
                q.offer(node.left);
            }
            if (node.right != null) {
                q.offer(node.right);
            }
        }
        result.add(level);
    }
    return result;
}
```

Time Complexity: O(n)

Space Complexity: O(width)

##### Solution 2: dfs

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    dfs(root, 0, result);
    return result;
}

private void dfs(TreeNode root, int level, List<List<Integer>> result) {
    if (root == null) {
        return;
    }
    if (result.size() == level) {
        result.add(new ArrayList<>());
    }
    result.get(level).add(root.val);
    dfs(root.left, level + 1, result);
    dfs(root.right, level + 1, result);
}
```

Time Complexity: O(n)

Space Complexity: O(height)

#### [LeetCode 103](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/) Binary Tree Zigzag Level Order Traversal (medium)

- Given the `root` of a binary tree, return _the zigzag level order traversal of its nodes' values_. (i.e., from left to right, then right to left for the next level and alternate between).
- **Example 1:**
    - <img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" style="zoom:67%;" />
    - **Input:** root = `[3,9,20,null,null,15,7]`
    - **Output:** `[[3],[20,9],[15,7]]`
- **Example 2:**
    - **Input:** root = `[1]`
    - **Output:** `[[1]]`
- **Example 3:**
    - **Input:** root = `[]`
    - **Output:** `[]`
- **Constraints:**
    -   The number of nodes in the tree is in the range `[0, 2000]`.
    -   `-100 <= Node.val <= 100`

##### Solution 1: bfs

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    Deque<TreeNode> dq = new ArrayDeque<>();
    dq.offer(root);
    int depth = 0;
    while (!dq.isEmpty()) {
        List<Integer> level = new ArrayList<>();
        int size = dq.size();
        for (int i = 0; i < size; i++) {
            if (depth % 2 == 0) {
                TreeNode node = dq.pollFirst();
                level.add(node.val);
                if (node.left != null) {
                    dq.offerLast(node.left);
                }
                if (node.right != null) {
                    dq.offerLast(node.right);
                }
            } else {
                TreeNode node = dq.pollLast();
                level.add(node.val);
                if (node.right != null) {
                    dq.offerFirst(node.right);
                }
                if (node.left != null) {
                    dq.offerFirst(node.left);
                }
            }
        }
        result.add(level);
        depth++;
    }
    return result;
}
```

Time Complexity: O(n)

Space Complexity: O(width)

##### Solution 2: dfs

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    dfs(root, 0, result);
    return result;
}

private void dfs(TreeNode root, int depth, List<List<Integer>> result) {
    if (root == null) {
        return;
    }
    if (depth == result.size()) {
        List<Integer> level = new ArrayList<>();
        level.add(root.val);
        result.add(level);
    } else {
        if (depth % 2 == 0) {
            result.get(depth).add(root.val);
        } else {
            result.get(depth).add(0, root.val);
        }
    }
    dfs(root.left, depth + 1, result);
    dfs(root.right, depth + 1, result);
}
```

Time Complexity: O(n)

Space Complexity: O(height)

#### [LeetCode 107](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/) Binary Tree Level Order Traversal II (medium)

- Given the `root` of a binary tree, return _the bottom-up level order traversal of its nodes' values_. (i.e., from left to right, level by level from leaf to root).
- **Example 1:**
    - <img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" style="zoom:67%;" />
    - **Input:** root = `[3,9,20,null,null,15,7]`
    - **Output:** `[[15,7],[9,20],[3]]`
- **Example 2:**
    - **Input:** root = `[1]`
    - **Output:** `[[1]]`
- **Example 3:**
    - **Input:** root = `[]`
    - **Output:** `[]`
- **Constraints:**
    -   The number of nodes in the tree is in the range `[0, 2000]`.
    -   `-1000 <= Node.val <= 1000`

##### Solution 1: bfs

```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    Queue<TreeNode> q = new ArrayDeque<>();
    q.offer(root);
    while (!q.isEmpty()) {
        List<Integer> level = new ArrayList<>();
        int size = q.size();
        for (int i = 0; i < size; i++) {
            TreeNode node = q.poll();
            level.add(node.val);
            if (node.left != null) {
                q.offer(node.left);
            }
            if (node.right != null) {
                q.offer(node.right);
            }
        }
        result.add(0, level);
    }
    return result;
}
```

Time Complexity: O(n)

Space Complexity: O(width)

##### Solution 2: dfs

```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    dfs(root, 0, result);
    return result;
}

private void dfs(TreeNode root, int depth, List<List<Integer>> result) {
    if (root == null) {
        return;
    }
    if (depth == result.size()) {
        List<Integer> level = new ArrayList<>();
        level.add(root.val);
        result.add(0, level);
    } else {
        result.get(result.size() - depth - 1).add(root.val);
    }
    dfs(root.left, depth + 1, result);
    dfs(root.right, depth + 1, result);
}
```

Time Complexity: O(n)

Space Complexity: O(height)

#### [LeetCode 429](https://leetcode.com/problems/n-ary-tree-level-order-traversal/) N-ary Tree Level Order Traversal (medium)

- Given an n-ary tree, return the _level order_ traversal of its nodes' values.
- _Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples)._
- **Example 1:**
    - <img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" style="zoom:50%;" />
    - **Input:** root = `[1,null,3,2,4,null,5,6]`
    - **Output:** `[[1],[3,2,4],[5,6]]`
- **Example 2:**
    - <img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" style="zoom:50%;" />
    - **Input:** root = `[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]`
    - **Output:** `[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]`
- **Constraints:**
    -   The height of the n-ary tree is less than or equal to `1000`
    -   The total number of nodes is between `[0, 10^4]`

##### Solution: bfs

```java
public List<List<Integer>> levelOrder(Node root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    Queue<Node> q = new ArrayDeque<>();
    q.offer(root);
    while (!q.isEmpty()) {
        List<Integer> level = new ArrayList<>();
        int size = q.size();
        for (int i = 0; i < size; i++) {
            Node node = q.poll();
            level.add(node.val);
            for (Node child : node.children) {
                q.offer(child);
            }
        }
        result.add(level);
    }
    return result;
}
```

Time Complexity: O(n)

Space Complexity: O(width)

### Vertical Order

#### [LeetCode 314](https://leetcode.com/problems/binary-tree-vertical-order-traversal/) Binary Tree Vertical Order Traversal (medium)

- Given the `root` of a binary tree, return _**the vertical order traversal** of its nodes' values_. (i.e., from top to bottom, column by column).
- If two nodes are in the same row and column, the order should be from **left to right**.
- **Example 1:**
    - <img src="https://assets.leetcode.com/uploads/2021/01/28/vtree1.jpg" style="zoom:67%;" />
    - **Input:** root = `[3,9,20,null,null,15,7]`
    - **Output:** `[[9],[3,15],[20],[7]]`
- **Example 2:**
    - <img src="https://assets.leetcode.com/uploads/2021/01/28/vtree2-1.jpg" style="zoom:67%;" />
    - **Input:** root = `[3,9,8,4,0,1,7]`
    - **Output:** `[[4],[9],[3,0,1],[8],[7]]`
- **Example 3:**
    - <img src="https://assets.leetcode.com/uploads/2021/01/28/vtree2.jpg" style="zoom:67%;" />
    - **Input:** root = `[3,9,8,4,0,1,7,null,null,null,2,5]`
    - **Output:** `[[4],[9,5],[3,0,1],[8,2],[7]]`
- **Constraints:**
    -   The number of nodes in the tree is in the range `[0, 100]`.
    -   `-100 <= Node.val <= 100`

##### Solution 1: bfs

```java
public List<List<Integer>> verticalOrder(TreeNode root) {
	List<List<Integer>> result = new ArrayList<>();
	if (root == null) {
		return result;
	}
	Map<Integer, List<Integer>> map = new HashMap<>();
	Queue<Pair<TreeNode, Integer>> queue = new ArrayDeque<>();
	queue.offer(new Pair(root, 0));
	int min = 0, max = 0;
	while (!queue.isEmpty()) {
		Pair<TreeNode, Integer> pair = queue.poll();
		TreeNode node = pair.getKey();
		int column = pair.getValue();
		if (node != null) {
			map.computeIfAbsent(column, k -> new ArrayList<>()).add(node.val);
			min = Math.min(min, column);
			max = Math.max(max, column);
			queue.offer(new Pair(node.left, column - 1));
			queue.offer(new Pair(node.right, column + 1));
		}
	}
	for (int i = min; i <= max; i++) {
		result.add(map.get(i));
	}
	return result;
}
```

Time Complexity: O(n)

Space Complexity: O(width)

##### Solution 2: dfs

```java
public List<List<Integer>> verticalOrder(TreeNode root) {
	List<List<Integer>> result = new ArrayList<>();
	if (root == null) {
		return result;
	}
    Map<Integer, List<Pair<Integer, Integer>>> map = new HashMap<>();
    int[] minmax = new int[2];
    dfs(root, 0, 0, minmax, map);
    for (int i = minmax[0]; i <= minmax[1]; i++) {
		Collections.sort(map.get(i), (a, b) -> a.getKey() - b.getKey());
        List<Integer> column = new ArrayList<>();
        for (Pair<Integer, Integer> p : map.get(i)) {
            column.add(p.getValue());
        }
        result.add(column);
	}
    return result;
}

private void dfs(TreeNode root, int row, int column, int[] minmax, Map<Integer, List<Pair<Integer, Integer>>> map) {
    if (root == null) {
        return;
    }
    map.computeIfAbsent(column, k -> new ArrayList<>()).add(new Pair(row, root.val));
	minmax[0] = Math.min(minmax[0], column);
	minmax[1] = Math.max(minmax[1], column);
    dfs(root.left, row + 1, column - 1, minmax, map);
    dfs(root.right, row + 1, column + 1, minmax, map);
}
```

Time Complexity: O(nlogn)

Space Complexity: O(height)

#### [LeetCode 987](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/) Vertical Order Traversal of a Binary Tree (hard)

- Given the `root` of a binary tree, calculate the **vertical order traversal** of the binary tree.
- For each node at position `(row, col)`, its left and right children will be at positions `(row + 1, col - 1)` and `(row + 1, col + 1)` respectively. The root of the tree is at `(0, 0)`.
- The **vertical order traversal** of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.
- Return _the **vertical order traversal** of the binary tree_.
- **Example 1:**
    - <img src="https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg" style="zoom:67%;" />
    - **Input:** root = `[3,9,20,null,null,15,7]`
    - **Output:** `[[9],[3,15],[20],[7]]`
    - **Explanation:**
        - Column -1: Only node 9 is in this column.
        - Column 0: Nodes 3 and 15 are in this column in that order from top to bottom.
        - Column 1: Only node 20 is in this column.
        - Column 2: Only node 7 is in this column.
- **Example 2:**
    - <img src="https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg" style="zoom:67%;" />
    - **Input:** root = `[1,2,3,4,5,6,7]`
    - **Output:** `[[4],[2],[1,5,6],[3],[7]]`
    - **Explanation:**
        - Column -2: Only node 4 is in this column.
        - Column -1: Only node 2 is in this column.
        - Column 0: Nodes 1, 5, and 6 are in this column. 1 is at the top, so it comes first. 5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.
        - Column 1: Only node 3 is in this column.
        - Column 2: Only node 7 is in this column.
- **Example 3:**
    - <img src="https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg" style="zoom:67%;" />
    - **Input:** root = `[1,2,3,4,6,5,7]`
    - **Output:** `[[4],[2],[1,5,6],[3],[7]]`
    - **Explanation:**
        - This case is the exact same as example 2, but with nodes 5 and 6 swapped.
        - Note that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.
- **Constraints:**
    -   The number of nodes in the tree is in the range `[1, 1000]`.
    -   `0 <= Node.val <= 1000`

##### Solution 1: bfs

```java
public List<List<Integer>> verticalTraversal(TreeNode root) {
	List<List<Integer>> result = new ArrayList<>();
	if (root == null) {
		return result;
	}
	Map<Integer, List<Pair<Integer, Integer>>> map = new HashMap<>();
	Queue<Pair<TreeNode, int[]>> queue = new ArrayDeque<>();
	queue.offer(new Pair(root, new int[]{0, 0}));
	int min = 0, max = 0;
	while (!queue.isEmpty()) {
		Pair<TreeNode, int[]> pair = queue.poll();
		TreeNode node = pair.getKey();
        int row = pair.getValue()[0];
		int column = pair.getValue()[1];
		if (node != null) {
			map.computeIfAbsent(column, k -> new ArrayList<>()).add(new Pair(row, node.val));
			min = Math.min(min, column);
			max = Math.max(max, column);
			queue.offer(new Pair(node.left, new int[]{row + 1, column - 1}));
			queue.offer(new Pair(node.right, new int[]{row + 1, column + 1}));
		}
	}
	for (int i = min; i <= max; i++) {
		Collections.sort(map.get(i), (a, b) -> a.getKey() == b.getKey() ? a.getValue() - b.getValue() : a.getKey() - b.getKey());
        List<Integer> column = new ArrayList<>();
        for (Pair<Integer, Integer> p : map.get(i)) {
            column.add(p.getValue());
        }
        result.add(column);
	}
	return result;
}
```

Time Complexity: O(nlog(width))

Space Complexity: O(width)

##### Solution 2: dfs

```java
public List<List<Integer>> verticalTraversal(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
	if (root == null) {
		return result;
	}
    Map<Integer, List<Pair<Integer, Integer>>> map = new HashMap<>();
    int[] minmax = new int[2];
    dfs(root, 0, 0, minmax, map);
    for (int i = minmax[0]; i <= minmax[1]; i++) {
		Collections.sort(map.get(i), (a, b) -> a.getKey() == b.getKey() ? a.getValue() - b.getValue() : a.getKey() - b.getKey());
        List<Integer> column = new ArrayList<>();
        for (Pair<Integer, Integer> p : map.get(i)) {
            column.add(p.getValue());
        }
        result.add(column);
	}
    return result;
}

private void dfs(TreeNode root, int row, int column, int[] minmax, Map<Integer, List<Pair<Integer, Integer>>> map) {
    if (root == null) {
        return;
    }
    map.computeIfAbsent(column, k -> new ArrayList<>()).add(new Pair(row, root.val));
	minmax[0] = Math.min(minmax[0], column);
	minmax[1] = Math.max(minmax[1], column);
    dfs(root.left, row + 1, column - 1, minmax, map);
    dfs(root.right, row + 1, column + 1, minmax, map);
}
```

Time Complexity: O(nlogn)

Space Complexity: O(height)

## 4. Priority Queue

```java
PriorityQueue<Integer> minHeap = new PriorityQueue<>();
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
```

### [LeetCode 373](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/) Find K Pairs with Smallest Sums (medium)

- You are given two integer arrays `nums1` and `nums2` sorted in **ascending order** and an integer `k`.
- Define a pair `(u, v)` which consists of one element from the first array and one element from the second array.
- Return _the_ `k` _pairs_ `(u1, v1), (u2, v2), ..., (uk, vk)` _with the smallest sums_.
- **Example 1:**
    - **Input:** nums1 = [1,7,11], nums2 = [2,4,6], k = 3
    - **Output:** `[[1,2],[1,4],[1,6]]`
    - **Explanation:** The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
- **Example 2:**
    - **Input:** nums1 = [1,1,2], nums2 = [1,2,3], k = 2
    - **Output:** `[[1,1],[1,1]]`
    - **Explanation:** The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
- **Example 3:**
    - **Input:** nums1 = [1,2], nums2 = [3], k = 3
    - **Output:** `[[1,3],[2,3]]`
    - **Explanation:** All possible pairs are returned from the sequence: [1,3],[2,3]
- **Constraints:**
    -   `1 <= nums1.length, nums2.length <= 10^5`
    -   `-10^9 <= nums1[i], nums2[i] <= 10^9`
    -   `nums1` and `nums2` both are sorted in **ascending order**.
    -   `1 <= k <= 10^4`

#### Solution 0: (memory limit exceeded)

```java
public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
    List<List<Integer>> result = new ArrayList<>();
    boolean[][] visited = new boolean[nums1.length][nums2.length];
    PriorityQueue<int[]> minHeap = new PriorityQueue<>(k, new Comparator<>() {
        @Override
        public int compare(int[] c1, int[] c2) {
            if (c1[0] == c2[0]) {
                return 0;
            }
            return c1[0] < c2[0] ? -1 : 1;
        }
    });
    minHeap.offer(new int[]{nums1[0] + nums2[0], 0, 0});
    visited[0][0] = true;
    for (int i = 0; i < k; i++) {
        if (minHeap.isEmpty()) {
            break;
        }
        int[] current = minHeap.poll();
        List<Integer> list = new ArrayList<>();
        list.add(nums1[current[1]]);
        list.add(nums2[current[2]]);
        result.add(list);
        if (current[1] + 1 < nums1.length && !visited[current[1] + 1][current[2]]) {
            minHeap.offer(new int[]{nums1[current[1] + 1] + nums2[current[2]], current[1] + 1, current[2]});
            visited[current[1] + 1][current[2]] = true;
        }
        if (current[2] + 1 < nums2.length && !visited[current[1]][current[2] + 1]) {
            minHeap.offer(new int[]{nums1[current[1]] + nums2[current[2] + 1], current[1], current[2] + 1});
            visited[current[1]][current[2] + 1] = true;
        }
    }
    return result;
}
```

Time Complexity: O(klogk)

Space Complexity: O(k + n^2)

#### Solution

```java
public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
    List<List<Integer>> result = new ArrayList<>();
    if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) {
        return result;
    }
    PriorityQueue<int[]> minHeap = new PriorityQueue<>((a,b) -> (a[0] + a[1]) - (b[0] + b[1]));
    for (int i = 0; i < nums1.length && i < k; i++) {
        minHeap.offer(new int[]{nums1[i], nums2[0], 0});
    }
    for (int i = 0; i < k && !minHeap.isEmpty(); i++) {
        int[] current = minHeap.poll();
        result.add(List.of(current[0], current[1]));
        int nums2index = current[2];
        if (nums2index + 1 < nums2.length) {
            minHeap.offer(new int[]{current[0], nums2[nums2index + 1], nums2index + 1});
        }
    }
    return result;
}
```

Time Complexity: O(klogk)

Space Complexity: O(k)

### [LeetCode 692](https://leetcode.com/problems/top-k-frequent-words/) Top K Frequent Words (medium)

- Given an array of strings `words` and an integer `k`, return _the_ `k` _most frequent strings_.
- Return the answer **sorted** by **the frequency** from highest to lowest. Sort the words with the same frequency by their **lexicographical order**.
- **Example 1:**
    - **Input:** words = ["i","love","leetcode","i","love","coding"], k = 2
    - **Output:** ["i","love"]
    - **Explanation:** "i" and "love" are the two most frequent words.
        - Note that "i" comes before "love" due to a lower alphabetical order.
- **Example 2:**
    - **Input:** words = ["the","day","is","sunny","the","the","the","sunny","is","is"], k = 4
    - **Output:** ["the","is","sunny","day"]
    - **Explanation:** "the", "is", "sunny" and "day" are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.
- **Constraints:**
    -   `1 <= words.length <= 500`
    -   `1 <= words[i].length <= 10`
    -   `words[i]` consists of lowercase English letters.
    -   `k` is in the range `[1, The number of **unique** words[i]]`
- **Follow-up:** Could you solve it in `O(nlogk)` time and `O(n)` extra space?

#### Solution: min heap

```java
public List<String> topKFrequent(String[] words, int k) {
    List<String> result = new ArrayList<>();
    if (words == null || words.length == 0) {
        return result;
    }
    Map<String, Integer> frequency = new HashMap<>();
    for (String s : words) {
        frequency.put(s, frequency.getOrDefault(s, 0) + 1);
    }
    PriorityQueue<String> minHeap = new PriorityQueue<>((w1, w2) -> frequency.get(w1).equals(frequency.get(w2)) ? w2.compareTo(w1) : frequency.get(w1).compareTo(frequency.get(w2)));
    for (String word : frequency.keySet()) {
        minHeap.offer(word);
        if (minHeap.size() > k) {
            minHeap.poll();
        }
    }
    while (!minHeap.isEmpty()) {
        result.add(minHeap.poll());
    }
    Collections.reverse(result);
    return result;
}
```

##### `Map.Entry<K, V>`

```java
public List<String> topKFrequent(String[] words, int k) {
    List<String> result = new ArrayList<>();
    if (words == null || words.length == 0) {
        return result;
    }
    Map<String, Integer> frequency = new HashMap<>();
    for (String s : words) {
        frequency.put(s, frequency.getOrDefault(s, 0) + 1);
    }
    PriorityQueue<Map.Entry<String, Integer>> minHeap = new PriorityQueue<>(k,
        new Comparator<Map.Entry<String, Integer>>() {
            @Override
            public int compare(Map.Entry<String, Integer> e1, Map.Entry<String, Integer> e2) {
                if (e1.getValue().equals(e2.getValue())) {
                    return e2.getKey().compareTo(e1.getKey());
                }
                return e1.getValue().compareTo(e2.getValue());
            }
        }
    );
    for (Map.Entry<String, Integer> entry : frequency.entrySet()) {
        minHeap.offer(entry);
        if (minHeap.size() > k) {
            minHeap.poll();
        }
    }
    while (!minHeap.isEmpty()) {
        result.add(minHeap.poll().getKey());
    }
    Collections.reverse(result);
    return result;
}
```

Time Complexity: O(n + nlogk)

Space Complexity: O(n)

### [LeetCode 347](https://leetcode.com/problems/top-k-frequent-elements/) Top K Frequent Elements (medium)

- Given an integer array `nums` and an integer `k`, return _the_ `k` _most frequent elements_. You may return the answer in **any order**.
- **Example 1:**
    - **Input:** nums = [1,1,1,2,2,3], k = 2
    - **Output:** [1,2]
- **Example 2:**
    - **Input:** nums = [1], k = 1
    - **Output:** [1]
- **Constraints:**
    -   `1 <= nums.length <= 10^5`
    -   `-10^4 <= nums[i] <= 10^4`
    -   `k` is in the range `[1, the number of unique elements in the array]`.
    -   It is **guaranteed** that the answer is **unique**.
- **Follow up:** Your algorithm's time complexity must be better than `O(nlogn)`, where n is the array's size.

#### Solution 1: min heap

```java
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int num : nums) {
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
    PriorityQueue<Integer> minHeap = new PriorityQueue<>((a, b) -> map.get(a) - map.get(b));
    for (int key : map.keySet()) {
        minHeap.offer(key);
        if (minHeap.size() > k) {
            minHeap.poll();
        }
    }
    int[] result = new int[k];
    int index = k - 1;
    while (!minHeap.isEmpty()) {
        result[index--] = minHeap.poll();
    }
    return result;
}
```

Time Complexity: O(n + nlogk)

Space Complexity: O(n)

#### Solution 2: quick select

```java
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int num : nums) {
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
    int size = map.size();
    int[] keys = new int[size];
    int index = 0;
    for (int key: map.keySet()) {
        keys[index++] = key;
    }
    quickselect(keys, 0, size - 1, size - k, map);
    return Arrays.copyOfRange(keys, size - k, size);
}

private void quickselect(int[] keys, int left, int right, int kSmallest, Map<Integer, Integer> map) {
    if (left >= right) {
        return;
    }
    int pivot = left + new Random().nextInt(right - left);
    pivot = partition(left, right, pivot, keys, map);
    if (pivot == kSmallest) {
        return;
    } else if (pivot < kSmallest) {
        quickselect(keys, pivot + 1, right, kSmallest, map);
    } else {
        quickselect(keys, left, pivot - 1, kSmallest, map);
    }
}

private int partition(int left, int right, int pivot, int[] keys, Map<Integer, Integer> map) {
    int pivotValue = map.get(keys[pivot]);
    swap(keys, pivot, right);
    int index = left;
    for (int i = left; i < right; i++) {
        if (map.get(keys[i]) < pivotValue) {
            swap(keys, i, index++);
        }
    }
    swap(keys, index, right);
    return index;
}

private void swap(int[] nums, int x, int y) {
    int temp = nums[x];
    nums[x] = nums[y];
    nums[y] = temp;
}
```

Time Complexity: O(n)

Space Complexity: O(n)

## 5. Implement Hashmap

```java
import java.util.Arrays;

public class MyHashMap<K, V> {
    static class Node<K, V> {
        final K key;
        V value;
        Node<K, V> next;

        Node(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }

    private Node<K, V>[] array;
    private int size;
    private float loadFactor;

    private static final int DEFAULT_CAPACITY = 5;
    private static final float DEFAULT_LOAD_FACTOR = 0.75f;
    private static final int SCALE_FACTOR = 2;

    public MyHashMap(int capacity, float loadFactor) {
        if (capacity <= 0) {
            throw new IllegalArgumentException("Capacity cannot be <= 0.");
        }
        array = (Node<K, V>[]) (new Node[capacity]);
        this.loadFactor = loadFactor;
        size = 0;
    }

    public MyHashMap() {
        this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Returns the number of key-value mappings in this map.
     *
     * @return the number of key-value mappings in this map
     */
    public synchronized int size() {
        return size;
    }

    public synchronized boolean isEmpty() {
        return size == 0;
    }

    public synchronized void clear() {
        Arrays.fill(array, null);
        size = 0;
    }

    /**
     * Associates the specified value with the specified key into this map.
     * If the key already exists, return the previously corresponding value.
     * If the key does not exist, return null.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with key, or null if there was no mapping for key.
     */
    public synchronized V put(K key, V value) {
        int index = getIndex(key);
        Node<K, V> current = array[index];
        while (current != null) {
            if (equalsKey(current.key, key)) {
                V result = current.value;
                current.value = value;
                return result;
            }
            current = current.next;
        }
        Node<K, V> newHead = new Node<>(key, value);
        newHead.next = array[index];
        array[index] = newHead;
        size++;
        if (needRehashing()) {
            rehashing();
        }
        return null;
    }

    private int getIndex(K key) {
        return hash(key) % array.length;
    }

    private int hash(K key) {
        if (key == null) {
            return 0;
        }
        int code = key.hashCode();
        return code & 0x7FFFFFFF;
    }

    private boolean equalsKey(K k1, K k2) {
        return k1 == k2 || k1 != null && k1.equals(k2);
    }

    private boolean needRehashing() {
        float ratio = (size + 0.0f) / array.length;
        return ratio >= loadFactor;
    }

    private boolean rehashing() {
        Node<K, V>[] oldArray = array;
        array = (Node<K, V>[]) (new Node[array.length * SCALE_FACTOR]);
        for (Node<K, V> node : oldArray) {
            while (node != null) {
                Node<K, V> next = node.next;
                int index = getIndex(node.key);
                node.next = array[index];
                array[index] = node;
                node = next;
            }
        }
        return true;
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or null if this map contains no mapping for the key.
     *
     * @param key the key whose associated value is to be returned
     * @return the value to which the specified key is mapped,
     *         or null if this map contains no mapping for the key
     */
    public synchronized V get(K key) {
        int index = getIndex(key);
        Node<K, V> current = array[index];
        while (current != null) {
            if (equalsKey(current.key, key)) {
                return current.value;
            }
            current = current.next;
        }
        return null;
    }

    /**
     * Returns true if this map contains a mapping for the specified key.
     *
     * @param key key whose presence in this map is to be tested
     * @return true if this map contains a mapping for the specified key
     */
    public synchronized boolean containsKey(K key) {
        int index = getIndex(key);
        Node<K, V> current = array[index];
        while (current != null) {
            if (equalsKey(current.key, key)) {
                return true;
            }
            current = current.next;
        }
        return false;
    }

    /**
     * Returns true if this map contains a mapping for the specified value.
     *
     * @param value value whose presence in this map is to be tested
     * @return true if this map contains a mapping for the specified value
     */
    public synchronized boolean containsValue(V value) {
        if (isEmpty()) {
            return false;
        }
        for (Node<K, V> node : array) {
            while (node != null) {
                if (equalsValue(node.value, value)) {
                    return true;
                }
                node = node.next;
            }
        }
        return false;
    }

    private boolean equalsValue(V v1, V v2) {
        return v1 == v2 || v1 != null && v1.equals(v2);
    }

    /**
     * Returns the value to which the specified key is mapped,
     or null if this map contains no mapping for the key.
     *
     * @param key the key which will be removed
     * @return the value to which the specified key is mapped,
     *         or null if this map contains no mapping for the key
     */
    public synchronized V remove(K key) {
        int index = getIndex(key);
        Node<K, V> previous = null;
        Node<K, V> current = array[index];
        while (current != null) {
            if (equalsKey(current.key, key)) {
                if (previous == null) {
                    array[index] = current.next;
                } else {
                    previous.next = current.next;
                }
                size--;
                return current.value;
            }
            previous = current;
            current = current.next;
        }
        return null;
    }
}
```

## 6. Implement LRU Cache

- 缓存文件置换机制是电脑处理缓存存储器的一种机制。电脑存储器空间的大小固定，无法容纳服务器上所有的文件，所以当有新的文件要被置换入缓存时，必须根据一定的原则来取代掉适当的文件。
- 缓存文件置换方法有:
    - 先进先出算法(FIFO): 最先进入的内容作为替换对象
    - 最近最少使用算法(LFU): 最近最少使用的内容作为替换对象
    - 最久未使用算法(LRU): 最久没有访问的内容作为替换对象
    - 非最近使用算法(NMRU): 在最近没有使用的内容中随机选择一个作为替换对象
    - Belady's Min

```java
public class LRUCache<K,V> {
    class Node<K,V> {
        K key;
        V value;
        Node<K,V> previous, next;
        public Node(){}
        public Node(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }
    private int capacity;
    private HashMap<K,Node> map;
    private Node<K,V> head;
    private Node<K,V> tail;
    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>(capacity);
        head = new Node<>();
        tail = new Node<>();
        head.next = tail;
        tail.previous = head;
    }

    public V get(K key) {
        Node<K,V> node = map.get(key);
        if (node == null) {
            return null;
        }
        moveNodeToHead(node);
        return node.value;
    }

    public void put(K key, V value) {
        Node<K,V> node = map.get(key);
        if (node == null) {
            if (map.size() >= capacity) {
                map.remove(tail.previous.key);
                removeTailNode();
            }
            Node<K,V> newNode = new Node<>(key, value);
            map.put(key, newNode);
            addToHead(newNode);
        } else {
            node.value = value;
            moveNodeToHead(node);
        }
    }

    private void addToHead(Node<K,V> newNode) {
        newNode.previous = head;
        newNode.next = head.next;
        head.next.previous = newNode;
        head.next = newNode;
    }

    private void moveNodeToHead(Node<K,V> node) {
        removeNode(node);
        addToHead(node);
    }

    private void removeNode(Node<K,V> node) {
        node.previous.next = node.next;
        node.next.previous = node.previous;
    }

    private void removeTailNode() {
        removeNode(tail.previous);
    }
}
```